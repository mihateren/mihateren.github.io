{"0": {
    "doc": "Глава 1. JVM и первая программа",
    "title": "Глава 1. JVM и первая программа",
    "content": " ",
    "url": "/chapters/chapter1.html",
    
    "relUrl": "/chapters/chapter1.html"
  },"1": {
    "doc": "Глава 1. JVM и первая программа",
    "title": "1. Почему Java — это удобно и круто",
    "content": "Представьте, что вы записали песню в формате mp3. Такой файл можно включить на любом устройстве — в машине, на телефоне, в холодильнике с экраном — потому что все они понимают этот формат. Точно так же работает и Java: вы пишете программу один раз, а запускать её можно где угодно, если там есть специальная программа — Java Virtual Machine (JVM). Java — это язык программирования, который придумали для того, чтобы программы работали на любом компьютере, где бы они ни были написаны. Его главный лозунг — “Write once, run anywhere” (Написал однажды — запускай где угодно). Это значит, что если вы написали программу на Windows, она без проблем запустится и на Linux, и на Mac, и даже на холодильнике, если там есть JVM. В отличие от языков вроде C++ или Go, где ваш код превращается в машинные инструкции конкретного процессора, Java компилируется в универсальный байткод. Этот байткод понимает любая JVM, а уже она сама разберётся, как запустить его на нужном железе. ",
    "url": "/chapters/chapter1.html#1-%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-java--%D1%8D%D1%82%D0%BE-%D1%83%D0%B4%D0%BE%D0%B1%D0%BD%D0%BE-%D0%B8-%D0%BA%D1%80%D1%83%D1%82%D0%BE",
    
    "relUrl": "/chapters/chapter1.html#1-почему-java--это-удобно-и-круто"
  },"2": {
    "doc": "Глава 1. JVM и первая программа",
    "title": "2. Как запускается Java-программа",
    "content": "Вспомните, как вы отправляете письмо за границу: сначала пишете его на русском, потом переводите на английский, а уже на месте его читает человек, который знает этот язык. С программой на Java происходит похожее. | Вы пишете исходный код — создаёте файл с расширением .java и пишете в нём свой код. | Компилируете код — специальная программа-компилятор (javac) превращает ваш код в байткод (файл .class). | Запускаете программу — JVM загружает байткод и начинает его выполнять. | . Когда вы запускаете программу, JVM делает несколько важных шагов: . | Загружает нужные классы (Class Loader). | Проверяет безопасность байткода. | Интерпретирует байткод построчно, а если какой-то участок используется часто — “на лету” превращает его в машинный код процессора (Just-In-Time компиляция, JIT). Благодаря этому часто используемые части программы работают очень быстро. | . Если сравнить с переводом книги: сначала вы переводите каждую фразу по словарю, но если фраза повторяется много раз, вы запоминаете её перевод и больше не заглядываете в словарь. Как Java находит и подгружает классы: роль ClassLoader . Представьте себе огромную библиотеку, где книги (классы) хранятся на разных полках, а библиотекарь (ClassLoader) приносит нужную книгу только тогда, когда вы её попросили. В Java классы не загружаются все сразу — они подгружаются по мере необходимости, и за это отвечает специальный механизм — ClassLoader. Когда вы запускаете программу, JVM не читает сразу все классы, которые есть в проекте. Она начинает с главного класса (того, где есть main), а остальные подгружает только тогда, когда они реально понадобятся. Например, если в вашей программе есть класс Cat, он будет загружен только тогда, когда вы впервые напишете new Cat() или обратитесь к его статическим полям/методам. Это позволяет: . | Загружать классы “на лету” (например, плагины, модули, сторонние библиотеки). | Изолировать классы из разных источников друг от друга. | Реализовать горячую замену кода, динамическую подгрузку и даже запускать несколько версий одной и той же библиотеки в одном приложении (например, в серверах приложений). | . Если вы попросили библиотекаря найти редкую книгу, он сначала ищет у себя (Application ClassLoader), потом спрашивает у заведующего отделом (Extension ClassLoader), а если и там нет — обращается к главному хранителю фонда (Bootstrap ClassLoader). Если ни у кого нет — книга не найдена, программа падает с ошибкой ClassNotFoundException. ",
    "url": "/chapters/chapter1.html#2-%D0%BA%D0%B0%D0%BA-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%D0%B0%D0%B5%D1%82%D1%81%D1%8F-java-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0",
    
    "relUrl": "/chapters/chapter1.html#2-как-запускается-java-программа"
  },"3": {
    "doc": "Глава 1. JVM и первая программа",
    "title": "4. Первая программа на Java",
    "content": "Давайте по классике посмотрим, как выглядит Hello World на Java: . public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello, World!\"); } } . | public class HelloWorld — объявляете класс с именем HelloWorld. В Java всё начинается с классов. | public static void main(String[] args) — специальный метод, с которого начинается выполнение программы. JVM всегда ищет именно этот метод. | System.out.println(\"Hello, World!\"); — команда, которая выводит текст на экран. | . На первый взгляд, программа выглядит громоздко. Но за этим стоит строгая структура: вы явно указываете, где начинается программа, что она делает, и как она взаимодействует с системой. Это помогает писать большие и сложные программы, где важна чёткость и порядок. ",
    "url": "/chapters/chapter1.html#4-%D0%BF%D0%B5%D1%80%D0%B2%D0%B0%D1%8F-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0-%D0%BD%D0%B0-java",
    
    "relUrl": "/chapters/chapter1.html#4-первая-программа-на-java"
  },"4": {
    "doc": "Глава 1. JVM и первая программа",
    "title": "5. Резюме",
    "content": "Java — это язык, который позволяет писать программы один раз и запускать их где угодно. Всё благодаря виртуальной машине (JVM), которая исполняет универсальный байткод. JDK — это ваш набор инструментов для разработки, JRE — среда для запуска, а JVM — сердце всей системы. В следующей главе мы разберёмся, какие бывают типы данных в Java и как с ними работать. ",
    "url": "/chapters/chapter1.html#5-%D1%80%D0%B5%D0%B7%D1%8E%D0%BC%D0%B5",
    
    "relUrl": "/chapters/chapter1.html#5-резюме"
  },"5": {
    "doc": "Глава 1. JVM и первая программа",
    "title": "Дополнительные материалы",
    "content": ". | Внутренности JVM | JIT компилятор | . ",
    "url": "/chapters/chapter1.html#%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D1%8B",
    
    "relUrl": "/chapters/chapter1.html#дополнительные-материалы"
  },"6": {
    "doc": "Глава 1. JVM и первая программа",
    "title": "Домашнее задание",
    "content": ". | Установите JetBrains IDEA. | Создайте первый проект и напишите программу HelloWorld. | . ",
    "url": "/chapters/chapter1.html#%D0%B4%D0%BE%D0%BC%D0%B0%D1%88%D0%BD%D0%B5%D0%B5-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5",
    
    "relUrl": "/chapters/chapter1.html#домашнее-задание"
  },"7": {
    "doc": "Глава 2. Типы данных",
    "title": "Глава 2. Типы данных",
    "content": " ",
    "url": "/chapters/chapter2.html",
    
    "relUrl": "/chapters/chapter2.html"
  },"8": {
    "doc": "Глава 2. Типы данных",
    "title": "1. Переменные",
    "content": "Представьте, что вы — маленький ребенок, который везде с собой носит коробочку. В эту коробочку вы кладете все, что вам нравится: камешки, конфеты, игрушки, мусор, но с единственным ограничением — в коробочке можно хранить только один предмет, или если вернуться в мир программирования — только одно значение. То есть, если вы решили, что в коробочке должен лежать камень, а в ней уже есть конфета, то вы обязаны убрать конфету, и положить туда камень. Такова суровая реальность. В Java, как и в других высокоуровневых языках программирования, вы, как разработчик, не задумываетесь над тем, куда пропадает предыдущее значение переменной. За вас его в памяти компьютера перезаписывает процессор (то есть кладет новое значение вместо старого). Именно так работают переменные. По сути это просто контейнеры для каких—то данных. В Java переменные объявляются следующим образом: . int a = 5; // целочисленная переменная double b = 36.6; // число с плавающей точкой . Давайте поймем что тут происходит: . 1) Первым словом мы всегда пишем тип данных. О типах данных мы поговорим ниже. 2) Затем мы пишем имя переменной по которому мы будем обращаться к ней, для того, чтобы работать с ее значением. 3) Ставим равно и пишем какое значение хотим туда положить. 4) Не забываем точку с запятой) . В нашем случае int и double являются типами данных для переменных a и b соответственно. ",
    "url": "/chapters/chapter2.html#1-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5",
    
    "relUrl": "/chapters/chapter2.html#1-переменные"
  },"9": {
    "doc": "Глава 2. Типы данных",
    "title": "2. Кто такие эти типы",
    "content": "Целые типы данных (byte, short, int, long) . int a = 10, b = 3, c = 3; System.out.println(a + b); // 13 — обычное сложение System.out.println(a / b); // 3 — дробная часть отбрасывается (целочисленное деление) System.out.println(b == c); // true — логическое значение // Переполнение на \"узком\" типе byte small = 127; // макс. значение byte small++; // +1 → «обнуляется» и уходит в –128 System.out.println(small); // —128 . Про переполнения подробнее тут . Вещественные числа (float, double) . double x = 10.0, y = 3.0; System.out.println(x / y); // 3.3333333333333335 — деление с остатком System.out.println(x * y); // 30.0 . Символы (char) . char c = 'A'; // Юникод‑код 65 System.out.println(c); // A System.out.println(c + 1); // 66 (65 + 1) — арифметика разрешена, результат → int . Логический тип (boolean) . boolean p = true, q = false; System.out.println(p &amp;&amp; q); // false — логическое «И» System.out.println(p || q); // true — логическое «ИЛИ» System.out.println(!p); // false — логическое «НЕ» . Итак, типы данных определяют два ключевых момента: 1) Сколько памяти нужно выделить для конкретной переменной 2) Какие операции над переменной разрешены . Строки (String) . А можно ли хранить строки? Конечно можно, например вот так: . String s = \"Строка с текстом\"; . Или вот так: . String s2 = new String(\"Еще одна строка с текстом\"); . В чем разница? Почему типы данных для чисел мы обозначали с маленьких букв, а для строк — с больших? Почему можно инициализировать строковую переменную просто через кавычки, а можно через new? Давайте разбираться. ",
    "url": "/chapters/chapter2.html#2-%D0%BA%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%B8%D0%B5-%D1%8D%D1%82%D0%B8-%D1%82%D0%B8%D0%BF%D1%8B",
    
    "relUrl": "/chapters/chapter2.html#2-кто-такие-эти-типы"
  },"10": {
    "doc": "Глава 2. Типы данных",
    "title": "3. Примитивы vs объекты. Стек vs куча",
    "content": "Примитивные типы . В Java типы данных делятся на два типа: примитивы и объекты. Первое относится к тем типам данных, которые пишутся с маленькой буквы (int, boolean, char и др). Они хранятся на стеке (кроме полей класса, но об этом позже), имеют дефолтные значения и заданный диапазон. Объекты . Объекты же — это составные типы данных, которые могут иметь в себе несколько полей из примитивов или же тоже объектов. Например определим класс котиков, который хранит и примитивы и объекты в своих полях: . public class Cat { int age; // примитив String name; // объект boolean isWellFed; // примитив } . Стек . Стек и куча — два отдела оперативной памяти, где JVM (или другая среда выполнения) хранит данные во время работы программы. Стек помимо примитивов хранит вызовы функций, ссылки на объекты и много другой системной информации, необходимой для работы программы. Стек как правило занимает не очень много места (порядка 1—8 мегабайт по умолчанию). Куча . Куча — это более объемная часть памяти, которая сохраняет в себе целые объекты. Объектами в Java является все, кроме примитивов (парадоксально). Куча по умолчанию занимает несколько гигабайт. Более подробно про работу этих двух участков памяти советую почитать тут. Пример размещения объектов и ссылок . Таким образом, если мы создаем экземпляр котика: . Cat vasya = new Cat(3, \"Вася\", false); . То переменная—ссылка vasya расположится на стеке, а сам объект Cat уже на куче. Упрощенная схема изображена на рисунке . Таким образом, когда мы будем обращаться к какому—то полю объекта vasya, Java перейдет по ссылке из стека в кучу и достанет нам это поле. Например: . Cat vasya = new Cat(3, \"Вася\", false); System.out.println(vasya.name); // Вася . А что там со строками? Почему мы создавали через кавычки и через new? . ",
    "url": "/chapters/chapter2.html#3-%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D1%8B-vs-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B-%D1%81%D1%82%D0%B5%D0%BA-vs-%D0%BA%D1%83%D1%87%D0%B0",
    
    "relUrl": "/chapters/chapter2.html#3-примитивы-vs-объекты-стек-vs-куча"
  },"11": {
    "doc": "Глава 2. Типы данных",
    "title": "4. Строки и строковый пул",
    "content": "Сравнение строк и String pool . Мы уже убедились, что ссылки хранятся в стеке, а реальные объекты — в куче. Но со строками всё чуть хитрее: Java держит для них отдельный шкафчик — String Pool (чаще переводят как строковый пул или таблица строк‑литералов). Давайте рассмотрим небольшой пример и увидим магию. String s1 = \"Hello\"; String s2 = \"Hello\"; String s3 = new String(\"Hello\"); System.out.println(s1 == s2); // true System.out.println(s1 == s3); // false . В первом случае Java нам сказала, что строка s1 равна строке s2. Все логично. Но почему s1 не равно s3? Ведь Hello и Hello ничем не отличается, можете побуквенно проверить. Java врет? . На самом деле нет. Все дело в оптимизациях JVM. В JVM строки (как и любые объекты) хранятся на куче, но в отдельной ее части, называемой стринг пулом (String pool). Java понимает, чтоо строки s1 и s2 полностью совпадают, и поэтому нет смысла выделять в памяти новый объект, ведь можно просто ссылку s2 направить в тот же участок памяти, куда указывает и s1. А вот со сторокой s3 все просто — поскольку мы написали оператор new, то мы указали JVM, что нам нужно выделить именно новый участок памяти, в который мы положим строку Hello (уже другую, отличную от s1). Ну и последним аргументом в пользу правоты Java будет сравнение объектов. Java любые объекты сравнивает по ссылкам, если мы их пытаемся сравнить через оператор сравнения ==. Если же мы хотим сравнить именно содержимое этих строк, то можно использовать метод equals: . String s1 = \"Hello\"; String s2 = \"Hello\"; String s3 = new String(\"Hello\"); System.out.println(s1.equals(s2)); // true System.out.println(s1.equals(s3)); // true . При использовании equals строки сравниваются именно по содержимому, и в этом примере мы, логично, получаем два true. Как работает создание строк . Таким образом, последовательность создания переменной—строки для JVM следующая: 1) Если используем оператор new, просто выделяем новый участок памяти и указываем ссылку на него. 2) Иначе, просмотреть String pool на наличие такой же строки, и если она найдена — положить в новую переменную ссылку на нее. Если такая строка не найдена, выделить новый участок памяти и положить ссылку на нее в переменную. Более подробно про методы работы со строками можно почитать здесь. Иммутабельность строк . Есть еще очень важный момент, который нужно знать про строки. На самом деле строки не изменяемы. Как же так? Ведь мы можем спокойно выполнить следующий код: . String name = \"Вася\"; name += \" Пупкин\"; System.out.println(name); // Вася Пупкин . Кажется, что строка изменилась, ведь это логично видно из вывода программы. Но все сложнее. Что на самом деле происходит в этот момент: 1) Первая строка кладёт в переменную name ссылку на готовый литерал “Вася” из строкового пула. 2) Оператор += не пытается “дописать” символы в тот же объект — вместо этого компилятор разворачивает его в name = new StringBuilder(name).append(\" Пупкин\").toString();. 3) StringBuilder склеивает два текста и вызывает .toString(), которое отдаёт совершенно новый объект — уже в обычной куче. Переменная name переезжает на эту свежесозданную строку; старая “Вася” остаётся нетронутой и может жить дальше, если где‑то ещё на неё ссылаются (например, в пуле). То есть мы не «меняем» строку, а просто оставляем старую и берём новую. Представьте, что каждая строка в Java — это табличка, приклеенная к двери. Как только клей застыл, надпись уже не сломать и не заменить: можно лишь перевесить табличку или сделать новую. Эта “застывшая надпись” и есть иммутабельность (immutable), то есть неизменяемость. Зачем такой жёсткий подход? Во‑первых, ради экономии памяти. Строки‑литералы лежат в строковом пуле и могут раздаваться разным переменным как визитные карточки: надпись одна, а держателей десятки. Во‑вторых, безопасность. Представь, что веб‑приложение сначала проверяет строку‑путь “uploads/avatar.png”: убеждается, что она лежит только в папке /uploads, не содержит ../, нет спец‑символов. Проверка прошла — значит, строке доверили и передают её дальше, например в код, который реально открывает файл. Если бы строка могла меняться, злоумышленник, удерживая ссылку на тот же объект, мог бы между этими двумя шагами превратить путь в ”../../etc/passwd” и получить доступ к системным файлам. Иммутабельность обрубает атаку «в два приёма»: после валидации объект уже забетонирован — во время передачи по цепочке методов его содержимое гарантированно остаётся тем же самым. Тот же принцип защищает и любые другие критические строки, по которым принимаются решения — от имён классов в механизме ClassLoader до ключей доступа в SecurityManager: проверил один раз — можешь больше не оглядываться, строку никто тихонько не подменит. Наконец, производительность JIT‑компилятора. Иммутабельные строки компилятор смело «сворачивает» в константы и вклеивает прямо в байткод, сокращая время на склейку каждого «Hello, ” + name`. Если бы строки можно было править, о таких оптимизациях пришлось бы забыть. Итог: клей на табличке — это гарант, что память используется бережно, потоки не дерутся, а виртуальная машина может разгоняться до максимума, не опасаясь внезапных «редактирований» текста на ходу. Внутреннее устройство строк . И последнее, что сегодня обсудим про строки — их представление в коде (привет Си с ее char[]). Строка в Java — это не «голый» массив букв, а целая коробка‑органайзер. Внутри, конечно, лежит набор символов (до Java 9 — char[], с Java 9 — компактный byte[] плюс флажок‑кодировщик), но рядом прячутся служебные ярлыки: закэшированный hash, метка кодировки, да и сам буфер объявлен final, чтобы никто не дорвался переклеить буквы. ",
    "url": "/chapters/chapter2.html#4-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-%D0%B8-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%BE%D0%B2%D1%8B%D0%B9-%D0%BF%D1%83%D0%BB",
    
    "relUrl": "/chapters/chapter2.html#4-строки-и-строковый-пул"
  },"12": {
    "doc": "Глава 2. Типы данных",
    "title": "Резюме",
    "content": "В этой главе мы разобрались, с тем, как Java хранит наши данные — с помощью переменных. Коробочка‑переменная всегда вмещает только один предмет: положил камень — конфету придётся вынуть. Чтобы компьютер знал, сколько места резервировать под этот «камень» и какие с ним допустимы действия, мы клеим на коробку ярлык‑тип. Примитивы (int, double, boolean…) легки и просты: живут на стеке, имеют фиксированный вес и набор операций. Объекты же — настоящие матрёшки: сами лежат в куче, а на стеке остаётся лишь ссылка‑указатель. Самый яркий пример — строки. Литералы в кавычках JVM складывает в отдельный «строковый пул», чтобы не плодить дубликаты: две переменные могут смотреть на один и тот же “Hello”. А вот new String(\"Hello\") — вынужденная роскошь, создающая свежий объект в куче и отнимающая лишние байты. В сухом остатке: типы данных определяют объём памяти и набор допустимых операций, стек хранит примитивы и ссылки, куча — реальные объекты, а строковый пул экономит место, повторно используя одинаковые тексты. ",
    "url": "/chapters/chapter2.html#%D1%80%D0%B5%D0%B7%D1%8E%D0%BC%D0%B5",
    
    "relUrl": "/chapters/chapter2.html#резюме"
  },"13": {
    "doc": "Глава 2. Типы данных",
    "title": "Доп материалы",
    "content": ". | Методы работы со строками | Переполнение типов | Работа стека и кучи | StringBuilder | Консольный ввод-вывод (без этого домашку не сделать) | . ",
    "url": "/chapters/chapter2.html#%D0%B4%D0%BE%D0%BF-%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D1%8B",
    
    "relUrl": "/chapters/chapter2.html#доп-материалы"
  },"14": {
    "doc": "Глава 2. Типы данных",
    "title": "Домашнее задание",
    "content": "Задача 1. Сумма двух чисел . Условие: Даны два целых числа a и b. Напишите программу, которая вычисляет их сумму. Входные данные: Два числа через пробел (-100 ≤ a, b ≤ 100). Выходные данные: Одно число — результат сложения. Пример: Вход: 5 3 Выход 8 . Задача 2. Деление с точностью . Условие: Даны два целых числа x и y. Выведите результат деления x / y с точностью до 3 знаков после запятой. Входные данные: Два числа через пробел (1 ≤ y ≤ 100, -1000 ≤ x ≤ 1000). Выходные данные: Вещественное число (округлить до 3 знаков). Пример: Вход: 7 3 Выход: 2.333 . Задача 3. Следующий символ . Условие: Дана английская буква в нижнем регистре. Выведите следующий за ней символ в алфавите (если это ‘z’, выведите ‘a’). Входные данные: Один символ (a ≤ char ≤ z). Выходные данные: Один символ. Пример: Вход: c Выход: d . Задача 4. Длина строки . Условие: Дана строка s (без пробелов). Выведите её длину. Входные данные: Строка (до 100 символов). Выходные данные: Целое число — длина строки. Вход: “hello” Выход: 5 . Задача 5. Чётное/нечётное . Условие: Дано целое число n. Определите, является ли оно чётным. Входные данные: Одно число (-1000 ≤ n ≤ 1000). Выходные данные: Строка \"even\" (чётное) или \"odd\" (нечётное). Пример: Вход: 7 Выход: odd . ",
    "url": "/chapters/chapter2.html#%D0%B4%D0%BE%D0%BC%D0%B0%D1%88%D0%BD%D0%B5%D0%B5-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5",
    
    "relUrl": "/chapters/chapter2.html#домашнее-задание"
  },"15": {
    "doc": "Глава 3. Условный оператор",
    "title": "Глава 3. Условный оператор",
    "content": "Мы с вами в предыдущих главах уже разобрались, что такое переменные и для чего они служат в программе. Но, согласитесь, если бы всё ограничивалось только переменными и калькуляторами, программирование было бы скучным и однообразным. Программы должны уметь реагировать на разные ситуации, принимать решения, менять своё поведение в зависимости от обстоятельств. ",
    "url": "/chapters/chapter3.html",
    
    "relUrl": "/chapters/chapter3.html"
  },"16": {
    "doc": "Глава 3. Условный оператор",
    "title": "1. Оператор if-else",
    "content": "Представьте: котик Боб стоит перед дверью с табличкой «Вход только с 18». Если Бобу есть 18 — его пустят, если нет — отправят домой. В программировании такие «развилки» называются условиями. Они позволяют программе принимать решения: что делать дальше, в зависимости от каких-то данных. В Java (и других языках) для этого существуют специальные конструкции — условные операторы. Самый базовый способ принять решение — это оператор if (от англ. “если”). Он проверяет условие, записанное в скобках (обязательно в скобках), и если оно истинно — выполняет указанный блок кода. Давайте увидим на примере той же двери и котика Боба, как решить задачу пропуска с 18 лет через Java: . int age = bob.getAge(); if (age &gt;= 18) { System.out.println(\"Доступ разрешён\"); } . Теперь наша программа умеет проверять возраст котика. Но ведь если у Боба возраст будет меньше 18, то он не сможет войти. А где же это отражено в коде? . Нам нужно выполнить какое-то действие, которое должно произойти, если не выполнилось условие. Для этого у нас есть в запасе оператор else. int age = bob.getAge(); if (age &gt;= 18) { System.out.println(\"Доступ разрешён\"); } else { System.out.println(\"Иди домой.\"); } . Теперь программа стала справедливее: если Бобу нет 18, его вежливо отправят домой. ",
    "url": "/chapters/chapter3.html#1-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-if-else",
    
    "relUrl": "/chapters/chapter3.html#1-оператор-if-else"
  },"17": {
    "doc": "Глава 3. Условный оператор",
    "title": "2. else if: когда вариантов больше двух",
    "content": "Но жизнь — штука сложная. Иногда вариантов больше, чем просто «да» или «нет». Например, если Боб пришёл не один, а с другом, и у каждого свой возраст. Или если мы хотим не только пускать или не пускать, но и поздравлять с совершеннолетием! . В таких случаях на помощь приходит связка else if — она позволяет добавить дополнительные условия. Пример: . int age = bob.getAge(); if (age &gt; 100) { System.out.println(\"Вы бессмертный кот! Вход без очереди.\"); } else if (age &gt;= 18) { System.out.println(\"Доступ разрешён\"); } else if (age &gt;= 0) { System.out.println(\"Иди домой.\"); } else { System.out.println(\"Ошибка: возраст не может быть отрицательным!\"); } . Программа идёт сверху вниз: как только находит подходящее условие — выполняет его и дальше не смотрит. Если ни одно не подошло, срабатывает последний else. Важно! Условий может быть сколько угодно, но порядок имеет значение: сначала — самые специфичные, потом — более общие. ",
    "url": "/chapters/chapter3.html#2-else-if-%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BE%D0%B2-%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B5-%D0%B4%D0%B2%D1%83%D1%85",
    
    "relUrl": "/chapters/chapter3.html#2-else-if-когда-вариантов-больше-двух"
  },"18": {
    "doc": "Глава 3. Условный оператор",
    "title": "3. Когда вариантов много и все они равны: switch-case",
    "content": "А теперь представьте, что у Боба есть любимый день недели, и он хочет узнать, что его ждёт в этот день. Можно, конечно, написать кучу if-else if, но это быстро превратится в кашу. Для таких случаев в Java есть оператор switch-case — он как большой распределительный щит: смотрит на значение переменной и отправляет ток по нужной ветке. Пример: . int day = 3; switch (day) { case 1: System.out.println(\"Понедельник: пора на работу\"); break; case 2: System.out.println(\"Вторник: можно немного расслабиться\"); break; case 3: System.out.println(\"Среда: маленькая пятница!\"); break; case 4: System.out.println(\"Четверг: уже почти выходные\"); break; case 5: System.out.println(\"Пятница: ура!\"); break; case 6: case 7: System.out.println(\"Выходной: можно спать целый день\"); break; default: System.out.println(\"Такого дня недели не бывает\"); } . Здесь переменная day сравнивается с каждым значением в case. Как только найдено совпадение — выполняется соответствующий блок, а затем оператор break завершает выполнение switch. Если ни один вариант не подошёл — срабатывает default. И тут важный момент. В Java есть подводный камень, на который часто натыкаются начинающие разработчики. Как вы думаете, что выведет следующая программа, если переменная number равна 2? . int number = 2; switch (number) { case 1: System.out.println(\"Один\"); case 2: System.out.println(\"Два\"); case 3: System.out.println(\"Три\"); default: System.out.println(\"Что-то ещё\"); } . Если вы ответили, что выведется только “Два”, то вы очень не правы. Результат: . Два Три Что-то ещё . Почему так? Потому что после совпадения с case 2 выполнение не останавливается, а “проваливается” дальше — выполняются все последующие case и default, пока не встретится break или не закончится switch. ",
    "url": "/chapters/chapter3.html#3-%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BE%D0%B2-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B8-%D0%B2%D1%81%D0%B5-%D0%BE%D0%BD%D0%B8-%D1%80%D0%B0%D0%B2%D0%BD%D1%8B-switch-case",
    
    "relUrl": "/chapters/chapter3.html#3-когда-вариантов-много-и-все-они-равны-switch-case"
  },"19": {
    "doc": "Глава 3. Условный оператор",
    "title": "Резюме",
    "content": ". | Оператор if позволяет выполнять код только при выполнении условия. | else — альтернативный путь, если условие не выполнено. | else if — для нескольких вариантов. | switch-case — удобно, когда вариантов много и сравнивается одна переменная. | Не забываем ставить break в switch-case) | Условия — основа принятия решений в программах. | . ",
    "url": "/chapters/chapter3.html#%D1%80%D0%B5%D0%B7%D1%8E%D0%BC%D0%B5",
    
    "relUrl": "/chapters/chapter3.html#резюме"
  },"20": {
    "doc": "Глава 3. Условный оператор",
    "title": "Домашнее задание",
    "content": "Задача 1. Минимум из двух чисел . Условие: Даны два целых числа. Выведите меньшее из них. Входные данные: Два числа через пробел. Выходные данные: Одно число — минимальное. Пример: Вход: 5 8 Выход: 5 . Задача 2. Класс оценки . Условие: Дано целое число от 1 до 5 — оценка. Выведите строку: “отлично”, “хорошо”, “удовлетворительно”, “плохо”, “очень плохо” (1 — очень плохо, 5 — отлично). Входные данные: Одно число (1–5). Выходные данные: Строка — оценка словами. Пример: Вход: 4 Выход: хорошо . Задача 3. Время суток . Условие: Дано число — час (0–23). Определите, к какому времени суток оно относится: ночь (0–5), утро (6–11), день (12–17), вечер (18–23). Входные данные: Одно число. Выходные данные: Строка — время суток. Пример: Вход: 7 Выход: утро . Задача 4. Чётность через switch . Условие: Дано целое число n. Используя switch-case, определите, чётное оно или нечётное. Входные данные: Одно число (−1000 ≤ n ≤ 1000). Выходные данные: Строка “even” (чётное) или “odd” (нечётное). Пример: Вход: 12 Выход: even . Задача 5. Калькулятор дней недели . Условие: Дано число от 1 до 7. Используя switch-case, выведите название дня недели (1 — понедельник, 7 — воскресенье). Если число не из диапазона — выведите “ошибка”. Входные данные: Одно число (1–7). Выходные данные: Строка — день недели или “ошибка”. Пример: Вход: 6 Выход: суббота . ",
    "url": "/chapters/chapter3.html#%D0%B4%D0%BE%D0%BC%D0%B0%D1%88%D0%BD%D0%B5%D0%B5-%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5",
    
    "relUrl": "/chapters/chapter3.html#домашнее-задание"
  },"21": {
    "doc": "Главная",
    "title": "Добро пожаловать в мою методичку",
    "content": "Зачем она нужна? В первую очередь, я пишу ее для себя — для систематизации своих знаний и выявления пробелов в них. Плюс, возможно, кому-то пригодится этот репозиторий для подготовки к собеседованиям, экзаменам или в целом будет полезен для расширения кругозора. В моём видении методичка должна стать неким путеводителем для человека, впервые услышавшего о джаве и заинтересовавшегося ею. Материал будет идти в том порядке, в каком я считаю нужным. | Java Core . | Типы данных и математические функции | Условные конструкции | Массивы и методы | Классы и интерфейсы | Работа с датами и файлами | Исключения и обработка ошибок | HashMap, HashSet | JVM, JMM и сборщики мусора | Многопоточность, потоко-безопасные коллекции | Lambda и Stream API, регулярные выражения | . | Изучим ООП и паттерны проектирования . | Четыре столпа: инкапсуляция, наследование, полиморфизм, абстракция | SOLID-принципы | Классические паттерны: Singleton, Factory, Observer, Strategy и др. | . | Научимся писать и понимать SQL | Поймем, как работает PostgreSQL изнутри | Потрогаем инструменты для работы с БД - JDBC и Hibernate | Разберем работу сети и DNS | Изучим и заглянем под капот Spring | Перейдем к архитектуре систем и приложений | И многое другое | . Каждую статейку я постараюсь подкрепить задачами, ссылками на материалы. В конечном счете должна выйти полноценная методичка, по которой можно преподавать. Моя цель — сделать в одном месте путеводитель по бекенд-разработке, который должен (хочется верить) любой старшеклассник или студент младших курсов. ",
    "url": "/#%D0%B4%D0%BE%D0%B1%D1%80%D0%BE-%D0%BF%D0%BE%D0%B6%D0%B0%D0%BB%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%B2-%D0%BC%D0%BE%D1%8E-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B8%D1%87%D0%BA%D1%83",
    
    "relUrl": "/#добро-пожаловать-в-мою-методичку"
  },"22": {
    "doc": "Главная",
    "title": "Главная",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"23": {
    "doc": "Java Core",
    "title": "Java Core",
    "content": "Выберите главу внизу или через боковое меню. ",
    "url": "/java-core.html",
    
    "relUrl": "/java-core.html"
  }
}
